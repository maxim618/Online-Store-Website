![CI](https://github.com/maxim618/Online-Store-Website/actions/workflows/ci.yml/badge.svg)

# Online Store Website - Technical Documentation

Online Store Website - backend - приложение интернет-магазина,
реализованное на Java и Spring Boot.

Проект ориентирован на демонстрацию архитектурных решений,
безопасной работы с пользовательскими данными и реализации
бизнес-логики e-commerce приложения.

---

## Функциональные возможности

- JWT-аутентификация
- Ролевая модель доступа (ROLE_USER / ROLE_ADMIN)
- Управление товарами через Admin API
- Корзина пользователя
- Оформление заказов
- Wishlist (избранные товары)
- DTO-слой для REST API 
- Unit и integration тесты
- Docker и CI

---

## Архитектура безопасности

Безопасность рассматривается как архитектурная часть системы.

Реализованные решения:

- Идентификация пользователя осуществляется исключительно через JWT
- userId не передаётся через query-параметры или тело запроса
- Контекст пользователя извлекается из SecurityContext
- Используется @AuthenticationPrincipal
- Admin API защищён с помощью method-level security (@PreAuthorize)
- Реализованы integration-тесты для проверки ролей и доступов

---

## Архитектура

Приложение построено по классической многослойной архитектуре (layered architecture)
с чётким разделением ответственности между слоями.

### За что отвечают слои

**Слой контроллеров**
- Обрабатывает HTTP-запросы
- Выполняет валидацию входных данных
- Не содержит бизнес-логики

**Сервисный слой**
- Содержит бизнес-логику приложения
- Управляет транзакциями
- Является единой точкой принятия бизнес-решений

**Слой репозиториев**
- Отвечает за доступ к данным
- Использует Spring Data JPA
- Инкапсулирует работу с базой данных

**Слой базы данных**
- MySQL
- Управляется через JPA/Hibernate

### DTO Слой

Для REST API используется отдельный DTO-слой:

- Entity-модели не используются напрямую во внешнем API
- DTO формируют стабильный контракт API
- Маппинг между entity и DTO выполняется с помощью MapStruct

Преимущества подхода:

- изоляцию доменной модели
- устойчивость API к изменениям бизнес-логики
- упрощение тестирования

---

## Архитектура корзины

Корзина реализована как **отдельный бизнес-агрегат** и не привязана
к конкретному механизму хранения.

---

### Абстракция CartStorage

Используется интерфейс хранения корзины:

- бизнес-логика работает через контракт
- конкретная реализация выбирается конфигурацией

Реализованные варианты:
- **JPA-based storage** — реляционная модель
- **Redis-compatible storage (Valkey)** — для high-load сценариев

Переключение реализации выполняется через конфигурационное свойство
без изменения бизнес-логики.

---

## Реализация Wishlist

- Wishlist защищён от дубликатов на уровне базы данных
- Используется уникальное ограничение (user_id, product_id)
- Повторное добавление товара корректно обрабатывается
- Поведение покрыто тестами

---

## Логика заказов

- Order формируется на основе текущего состояния корзины
- Order не зависит от жизненного цикла Cart
- Order flow не зависит от способа хранения корзины
- Данные товаров сохраняются как snapshot на момент покупки
- После успешного оформления заказа корзина очищается через CartStorage

---

## Payment - Платежный модуль

Платежная подсистема реализована как автономный модуль с четкими границами
и отсутствием прямой зависимости от внешних платежных систем.

### Назначение и особенности

- Изоляция платежной логики для последующего использования микросервисов
- Дизайн, ориентированный на соответствие требованиям (PCI DSS, защита персональных данных)
- Возможность тестирования с помощью TDD и фиктивных провайдеров
- Данные о держателях карт не хранятся и не обрабатываются.

### Архитектура

payment
 - ├── domain        # Payment entity and domain enums
 - ├── service       # PaymentService (application logic)
 - ├── provider      # PaymentProvider abstraction + Mock implementation
 - ├── repository    # Persistence abstraction
 - ├── dto           # DTOs
 - └── mapper        # MapStruct mappers

### Последовательность создания платежей

1. Заказ создан
2. Платеж инициализирован через "PaymentService"
3. PaymentProvider создает сеанс внешнего платежа
4. Система сохраняет только:

 - internal payment id
 - external payment id
 - payment status

5. Клиент получает URL платежа

### Providers

В настоящее время реализован:
- `MockPaymentProvider` — для разработки и тестирования

Реальные провайдеры (Stripe, YooKassa и т.д.) могут быть добавлены без изменения платежного
сервиса или модели домена.

---
### Безопасность и соответствие требованиям

- Система не хранит и не обрабатывает данные банковских карт
- За обработку конфиденциальных данных отвечают платежные провайдеры
- Приложение работает только с платежными идентификаторами и URL-адресами перенаправления
- Такая конструкция значительно сокращает область применения PCI DSS
- Обработка персональных данных может быть изолирована на уровне шлюза API

---

## Тестирование

В проекте реализованы:

- Unit-тесты сервисного слоя
- Integration-тесты REST API
- Security-тесты ролей и доступов
- Проверки edge-case сценариев
- Очистка состояния между тестами:
  - MySQL очищается через DbCleaner
  - Redis-compatible storage очищается перед тестами при использовании Valkey

---

### Redis / Valkey test mode

По умолчанию CI запускает тесты с использованием хранилища корзин на основе JPA.

---

##  Контейнеризация - Docker

Для локального запуска используется Docker Compose:

- MySQL в Docker-контейнере
- Redis-compatible storage (Valkey) в контейнере
- Конфигурация через переменные окружения (`.env`)

docker-compose up -d

---

## Непрерывная интеграция

Используется GitHub Actions:

- автоматический запуск тестов
- проверка сборки проекта
- выполнение при push и pull request

---

## План развития

- Оптимизация high-load сценариев
- Pagination и filtering
- Optimistic locking
- Event-driven обработка заказов
- OpenAPI / Swagger документация
- Возможная декомпозиция на сервисы

---

### Автор

Butmanov Maxim
GitHub: maxim618



