![CI](https://github.com/maxim618/Online-Store-Website/actions/workflows/ci.yml/badge.svg)

# Online Store Website - Technical Documentation

Online Store Website — backend‑приложение интернет‑магазина,
реализованное на Java и Spring Boot.
Проект ориентирован на демонстрацию архитектурных решений,
корректной работы с безопасностью и пользовательскими данными,
а также реализации ключевой бизнес‑логики e‑commerce систем.
Документ предназначен для технических специалистов (backend / lead / architect)
и описывает почему и как устроены основные подсистемы проекта.

---

## Функциональные возможности

- JWT-аутентификация
- Ролевая модель доступа (ROLE_USER / ROLE_ADMIN)
- Управление товарами через Admin API
- Корзина пользователя
- Оформление заказов
- Wishlist (избранные товары)
- DTO-слой для REST API 
- Unit и integration тесты
- Docker и CI

---

## Архитектура безопасности

Безопасность рассматривается как неотъемлемая часть архитектуры, 
а не как вспомогательная настройка.

Реализованные решения:

- Идентификация пользователя осуществляется исключительно через JWT
- userId не передаётся через query-параметры или тело запроса
- Контекст пользователя извлекается из SecurityContext
- Используется @AuthenticationPrincipal
- Admin API защищён с помощью method-level security (@PreAuthorize)
- Реализованы integration-тесты для проверки ролей и доступов

---

## Архитектура приложения

Приложение построено по классической layered architecture 
с чётким разделением ответственности между слоями.

### Ответственность слоёв

**Controller layer**
- Обрабатывает HTTP-запросы
- Выполняет валидацию входных данных
- Не содержит бизнес-логики

**Service layer**
- Реализовывает бизнес-логику приложения
- Управляет транзакциями
- Единая точка принятия бизнес-решений

**Repository layer**
- Отвечает за доступ к данным
- Использует Spring Data JPA
- Инкапсулирует работу с базой данных

**Database layer**
- MySQL
- Управляется через JPA/Hibernate

### DTO layer

Для REST API используется отдельный DTO-слой:

- Entity-модели не используются напрямую во внешнем API
- DTO формируют стабильный контракт API
- Маппинг между entity и DTO выполняется с помощью MapStruct

Преимущества подхода:

- изоляцию доменной модели
- устойчивость API к изменениям бизнес-логики
- упрощение тестирования

---

## Архитектура корзины (Cart)

Корзина реализована как **отдельный бизнес-агрегат** и не привязана
к конкретному механизму хранения.

---

### Абстракция CartStorage

Используется интерфейс хранения корзины:

- бизнес-логика работает через контракт
- конкретная реализация выбирается конфигурацией

Реализованные варианты:
- **JPA-based storage** — реляционная модель
- **Redis-compatible storage (Valkey)** — для high-load сценариев

Переключение реализации выполняется через конфигурационное свойство
без изменения бизнес-логики.

---

## Wishlist

- Wishlist защищён от дубликатов на уровне базы данных
- Используется уникальное ограничение (user_id, product_id)
- Повторное добавление товара корректно обрабатывается
- Поведение покрыто тестами

---

## Order logic

- Order формируется на основе текущего состояния корзины
- Order не зависит от жизненного цикла Cart
- Order flow не зависит от способа хранения корзины
- Данные товаров сохраняются как snapshot на момент покупки
- После успешного оформления заказа корзина очищается через CartStorage

---

## Payment module

Платежная подсистема реализована как автономный модуль с четкими границами
и отсутствием прямой зависимости от внешних платежных систем.

### Design goals

- Изоляция платёжной логики с прицелом на возможную микросервисную декомпозицию
- Архитектура, ориентированная на соответствие требованиям безопасности
- Минимизация области применения PCI DSS
- Высокая тестируемость (TDD, mock providers)

### Архитектура

payment
 - ├── domain        # Payment entity and domain enums
 - ├── service       # PaymentService (application logic)
 - ├── provider      # PaymentProvider abstraction + Mock implementation
 - ├── repository    # Persistence abstraction
 - ├── dto           # dto - API‑facing DTOs
 - └── mapper        # MapStruct mappers

### Payment flow

1. Заказ создан
2. Платеж инициализирован через "PaymentService"
3. PaymentProvider создает сеанс внешнего платежа
4. Система сохраняет только:

 - internal payment id
 - external payment id
 - payment status

5. Клиент получает payment URL

### Providers

Реализован:
- `MockPaymentProvider` — для разработки и тестирования

Реальные провайдеры (Stripe, YooKassa и т.д.) могут быть добавлены без изменения платежного
сервиса или модели домена.

---
### Security & Compliance

- Система не хранит и не обрабатывает данные банковских карт
- Обработка конфиденциальных данных делегирована платёжным провайдерам
- Приложение оперирует только платёжными идентификаторами и redirect URL
- Такая конструкция значительно сокращает область применения PCI DSS
- Обработка персональных данных может быть изолирована на уровне API Gateway

---

## Тестирование

В проекте реализованы:

- Unit-тесты сервисного слоя
- Integration-тесты REST API
- Security-тесты ролей и доступов
- Проверки edge-case сценариев
- Очистка состояния между тестами:
  - MySQL очищается через DbCleaner
  - Redis-compatible storage очищается перед тестами при использовании Valkey

---

### Redis / Valkey test mode

По умолчанию CI запускает тесты с использованием хранилища корзин на основе JPA.

---

##  Containerization - Docker

Для локального запуска используется Docker Compose:

- MySQL в Docker-контейнере
- Redis‑compatible storage (Valkey)
- Конфигурация через переменные окружения (`.env`)

docker-compose up -d

---

## Continuous Integration

Используется GitHub Actions:

- автоматический запуск тестов
- проверка сборки проекта
- выполнение при push и pull request

---

## Roadmap

- High‑load optimizations
- Pagination & filtering
- Optimistic locking
- Event‑driven order processing
- OpenAPI / Swagger documentation
- Possible service decomposition

---

### Author

Butmanov Maxim
GitHub: maxim618



